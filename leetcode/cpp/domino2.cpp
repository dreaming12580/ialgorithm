
#include <algorithm>

using namespace std;


class Solution {
private:
	// ones函数统计 x 的二进制表示中 1 的个数(相当于竖着摆放)
	int ones(int x) { 
		int res = 0;
		// x & (x - 1) 是一个位运算技巧， 可以把 x 的二进制表示中最右边的 1 变成 0
		for (; x != 0; x = (x & (x - 1))) {
			++res;
		}
		return res;
	}

	// 给定某一行的状态 (本质是二进制表示， 这里用 x 表示)
	// 求出在这种状态下， 这一行最多有多少块横着摆放的骨牌
	// 如 x = (110111011111)_2, 那么返回 4(从最低位向最高位搜索)
	int bricks(int x) {
		int res = 0;
		while (x) {
			// 位运算技巧: 这里的 j 相当于提取了 x 的最低位的 1
			int j = x & (-x);
			// 如果 x 的二进制表示中有连续两位的 1, 则可以横着摆放一个骨牌
			if (x & (j << 1)) {
				++res;
			}
			// 把上面两个位置 (x最低位的1 和左边相邻的那一位)变为0
			x &= ~j;
			x &= ~(j << 1);
		}
		return res;
	}

public:
	// @para:
	// M等于2的m次方， 也就是棋盘每行所有可能的状态总数，
	// (每行有m个格子，每个格子有被占用(包括有障碍物的情况和被骨牌覆盖的情况) 和未被占用两种可能)
	// blocked[i]表示第i行的障碍物情况(同样用二进制表示). 注意为了处理边界情况， 给原棋盘多添加一行
	// 并在这一行全部放上障碍物，所以声明为blocked[n + 1]
	// dp[i][status]表示第i行， 状态为status(棋盘的覆盖情况， 包括有障碍物的情况和被骨牌覆盖的情况，
	// status用二进制表示)时， 棋盘的第i行到第n -1行最多能添加的砖块数。
	// 和blocked同理， 需多添加一行，所以声明为dp[n + 1][M].
	// maxv：棋盘能摆放的骨牌的最大树目
	int domino(int n, int m, vector<vector<int>>& broken) {
		int M = (1 << m), blocked[n + 1] = {0}, dp[n + 1][M], maxv = 0;
		memset(dp, 0, M * sizeof(int));
		dp[n][M - 1] = 0, blocked[n] = M - 1; // 最后一行全是障碍
		// 初始化blocked数组
		for (auto v : broken) {
			blocked[v[0]] |= (1 << v[1]);
		}
		// =================================================================================================
		// 从棋盘最后一行(不包括新添加的)开始由下向上遍历棋盘每一行
		for (int l = n - 1; l >= 0; --l) {
			// 假设第 i 行在还没放置骨牌时的状态为100110, 下面这个for循环枚举了骨牌摆放的所有可能性
			// (1代表可能有骨牌放置，0代表没有骨牌放置(有障碍物或者空闲), 
			// st的二进制表示为 011001, 011000, 010001, 010000,...,000000)
			for (int st = (~blocked[l]) & (M - 1); ; st = (st - 1) & (~blocked[l])) {
				// 贪心策略，先考虑这一行骨牌竖着摆放的情况， 这时候就需要考虑后一行的障碍物情况
				// (S就是对于每种st, 考虑下一行障碍物后的状态，S中的1表示在这个位置允许竖着放一张骨牌)
				int maxcount = 0, S = st & (~blocked[l + 1]);
				// 枚举所有“竖着放”的可能性
				for (int k = S; ; k = (k - 1) & S) {
					// 当前行竖着摆 (ones(k)) + 
					// 横着摆(在竖着摆不下的情况下， 所以是 bricks(st & (~k)) +
					// 在当前行如此摆放的前提下，下一行到最后一行允许摆放骨牌的最大数量 
					// (注意dp数组中的status表示的是覆盖情况，所以在当前行竖着摆放的情况为 k(二进制)时，
					// 下一行的覆盖情况为 blocked[l + 1] | k)
					maxcount = max(ones(k) + bricks(st & (~k)) + dp[l + 1][blocked[l + 1] | k], maxcount);
					// 注意这里的break条件不能写进for循环的括号里面，
					// 因为当前行可能没有办法竖着摆放骨牌,但是得计算maxcount
					// (全是横着摆的情况，此时maxcount不一定等于0)
					if (k == 0) {
						break;
					}
				}
				// 更新当前行(第l行)在~st & (M - 1)的覆盖状态下第l行到第n - 1行最多能添加的砖块数
				dp[l][(~st) & (M - 1)] = maxcount;
				// 这里同理，不写进for循环(即使这一行啥东西也没有摆放， 也需要更新dp数组，
				// 此时dp[l][(~st) & (M - 1)] = dp[l + 1][block[l + 1]])
				if (st == 0) {
					break;
				}
			}
		}
		// 循环结束时，遍历第一行的所有可能覆盖状态，找到最大值即为最终答案
		for (int i = 0; i < M; ++i) {
			maxv = max(maxv, dp[0][i]);
		}
		return maxv;
	}
};














